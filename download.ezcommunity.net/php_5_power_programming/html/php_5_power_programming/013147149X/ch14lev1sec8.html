<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 14.8.&nbsp; Using ZPS (Zend Performance Suite)</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14lev1sec7.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch14lev1sec9.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="ch14lev1sec8"></a><h3 class="docSection1Title">14.8. Using ZPS (Zend Performance Suite)</h3>
<p class="docText"><span class="docEmphStrong">ZPS</span> is a commercial product from <a class="docLink" target="_blank" href="http://Zend.com">Zend.com</a>. ZPS provides tools for<a name="ch14index205"></a><a name="ch14index206"></a></p>
<ul><li><p class="docText">
<span class="docEmphStrong">Automatic Optimization.</span> 
By using the Zend Optimizer (<a class="docLink" target="_blank" href="http://www.zend.com/store/products/zend-optimizer.php">http://www.zend.com/store/products/zend-optimizer.php</a>), you can improve your performance by 20 percent without making any code changes.<a name="ch14index207"></a><a name="ch14index208"></a></P></li><LI><p class="docText">
<span class="docEmphStrong">Compiled-code Caching.</span> 
By using the Zend Performance Suite's Acceleration module (<a class="docLink" target="_blank" href="http://www.zend.com/store/products/zend-performance-suite.php">http://www.zend.com/store/products/zend-performance-suite.php</a>), you improve performance by 50300 percent, and sometimes even more for most applications.<a name="ch14index209"></a></p></LI><li><p class="docText">
<span class="docEmphStrong">Content-Caching.</span> 
When using the Zend Performance Suite's Content-Caching module, you can receive an enormous performance boostand literally reduce the execution overhead of your application to zero. Performance boost of 10,000 percent (100 times faster) are not uncommon with this practice.<a name="ch14index210"></a></p></li><li><p class="docText">
<span class="docEmphStrong">Content Compression.</span> 
Although being slightly different from all the aforementioned methods, compressing your content (typically the HTML parts of it) can result in your application appearing to perform faster and be more responsive because pages will take less time to transmit over the wire.<a name="ch14index211"></a></P></LI></ul>
<a name="ch14lev2sec12"></a><h4 class="docSection2Title">14.8.1. Automatic Optimization</h4>
<p class="docText">To understand <span class="docEmphStrong">Automatic Optimization</span>, you first should understand the execution architecture of PHP and the Zend Engine. Consider the following example:<a name="ch14index212"></a><a name="ch14index213"></a><a name="ch14index214"></a></p>
<pre>
&lt;?php
$i = 5;
$i++;
?&gt;
</pre><BR>
<p class="docText">How does PHP execute it? In practice, PHP employs a two-stage execution architecture. The first stage is <span class="docEmphasis">compiling</span> the source code into <span class="docEmphasis">intermediate code</span>, and the second stage is <span class="docEmphasis">executing</span> the <span class="docEmphasis">intermediate code</span>. What does intermediate code look like? If you are familiar with Assembly, intermediate code would look slightly familiar. It consists of relatively simple operations, which have a result and up to two operands. For instance, the intermediate code for the previous example is going to look more or less like this:</p>
<p><table cellspacing="0" class="allBorders" border="1" RULES="all" cellpadding="4"><colgroup><col width="159.5"><col width="390.5"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>1</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ASSIGN($i, 5)</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>2</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>T1 = $I</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>3</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>INC($i)</tt></p></td></TR></table></p><br>
<p class="docText">First, 5 is assigned to <tt>$i</tt>, then to the value of <tt>$i</tt> before the increment is retained in <tt>T1</tt>, and finally <tt>$i</tt> is incremented. But waitno one is using <tt>T1</tt> <sub>;</sub>isn't it a waste of time retaining it? The answer is yes, and this is exactly where Automatic Optimization comes into the picture.<a name="ch14index215"></a><a name="ch14index216"></a><a name="ch14index217"></a></p>
<p class="docText">The <span class="docEmphStrong">Zend Optimizer</span> (a part of the Zend Performance Suite, but also available for free from <a class="docLink" target="_blank" href="http://Zend.com">Zend.com</a>) works by analyzing your application's intermediate code, and replacing inefficient patterns with more efficient patterns that do the same thing. In our case, it would detect that post-increment is not really necessary, and replace it with pre-increment. In other words, it would get rid of Line 2, and the resultant code would look like this:<a name="ch14index218"></a></p>
<p><table cellspacing="0" class="allBorders" border="1" RULES="all" cellpadding="4"><colgroup><col width="159.5"><col width="390.5"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>1</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ASSIGN($i, 5)</tt></P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>2</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>INC($i)</tt></p></td></tr></table></P><br>
<p class="docText">Note that using the Zend Optimizer does not make <span class="docEmphasis">any</span> changes to your source code; the process happens in memory, and only operates on compiled, <span class="docEmphasis">intermediate</span> code. The biggest issue with automatic optimization is that typically it cannot yield more than 20 percent performance improvement, and in many cases, even much less. For that reason, automatic optimization should typically be complemented by additional performance improvement measures, such as compiled code caching.<a name="ch14index219"></a><a name="ch14index220"></a><a name="ch14index221"></a></p>
<a name="ch14lev2sec13"></a><H4 class="docSection2Title">14.8.2. Compiled Code Caching</h4>
<p class="docText">The Zend Performance Suite's <span class="docEmphStrong">Acceleration module</span>, which performs compiled code caching, is the simplest and often the most effective way to speed up your application. To understand what Acceleration does, we first need to go back to the execution architecture of the Zend Engine. In the previous section, you saw how the engine first compiles your PHP files into in-memory representations (<span class="docEmphasis">intermediate code</span>), and then executes. But then what? What happens when the engine is finished executing some piece of intermediate code?<a name="ch14index222"></a><a name="ch14index223"></a><a name="ch14index224"></a><a name="ch14index225"></a><a name="ch14index226"></a><a name="ch14index227"></a></P>
<p class="docText">The answer is almost nothing. That is, nothing special happens with the intermediate code; it simply becomes unallocated and destroyed. The next time the same script will be accessed, it will be compiled again into intermediate code before it's executed. This approach has several advantagesit features perfect isolation across different requests, low memory footprint, and perfect cross-platform compatibility. However, when using PHP to power a popular web site with millions of page views a day, repetitive compilation can become a bottleneck.</p>
<p class="docText">In order to boost performance, the ZPSs Acceleration module caches compiled intermediate code for repeated use. When installed, the ZPS replaces the compilation procedure of the Zend Engine with a modified one; the first time each file is accessed, the regular compiler is invoked. However, before the resultant intermediate code is passed to the execution engine, it is saved into shared memory for repeated later use. Once in shared memory, it is passed on to the execution engine, which runs it as if it was in regular memory. Later, accesses to the same file will no longer require the compilation stage, and will move directly to the execution stage. It's important to know that the ZPS saves each file separately, even if it is included from another file. That means that common <tt>include</tt> files (such as PEAR, or your own library files) are only kept in memory once, and are used by any piece of code that needs them.</p>
<p class="docText">Typical benefits from using the ZPS's acceleration module range between a 50300 percent performance increase. The results depend primarily on the nature of your application. Applications with longer execution overhead (for example, applications that spend most of their time waiting for the database to respond) benefit less from the nullification of the compilation overhead. On the other hand, applications that use a lot of files but have relatively short execution overhead (for example, OO applications with one class per file) can experience dramatic performance increase. Furthermore, the Zend Optimizer automatically detects the presence of the Zend Performance Suite, and performs more aggressive and time-consuming optimizations, which would otherwise make little sense to perform. The fact that the each file only has to be optimized once and then used many times, combined with the additional optimizations, further increases performance.<a name="ch14index228"></a><a name="ch14index229"></a><a name="ch14index230"></a></p>
<p class="docText">The ZPS Accelerator typically requires little configuration, if any. The default settings fit most web sites. However, you may want to increase the amount of available memory or the maximum number of accelerated files, for which you can use the ZPS Console (or Settings) tab (see <a class="docLink" href="#ch14fig12">Figure 14.12</a>).<a name="ch14index231"></a><a name="ch14index232"></a><a name="ch14index233"></a></p>
<a name="ch14fig12"></a><p><center><h5 class="docFigureTitle">Figure 14.12. Zend Performance Suite Console.</h5><a name="ch14index234"></a>
<p class="docText"><div class="v1"><a target="_self" href="images/013147149X/graphics/14fig12_alt.jpg;380137">[View full size image]</a></div><img border="0" alt="" width="500" height="359" SRC="images/013147149X/graphics/14fig12.jpg;380137"></p></center></p><br>
<a name="ch14lev2sec14"></a><h4 class="docSection2Title">14.8.3. Dynamic Content Caching</h4>
<p class="docText"><span class="docEmphStrong">Dynamic content caching</span> is by far the most effective way to boost performance, in the cases where it is applicable, because it eliminates both the compilation and execution overhead of your application. In simple terms, <span class="docEmphStrong">content caching</span> means saving the results of your application, typically HTML content, and then sending it out as-is again when another request comes along that asks for the same page. With dynamic content caching, improvement ratios of 10,000 percent (100 times better performance) are not uncommon. The downside is that it's not applicable for all PHP pages.<a name="ch14index235"></a><a name="ch14index236"></a><a name="ch14index237"></a><a name="ch14index238"></a></p>
<p class="docText">First, you have to become familiar with the concept behind caching dynamic content. Imagine a news site, such as <a class="docLink" target="_blank" href="http://cnn.com">cnn.com</a>. Is there any reason for CNN to generate this page from a database each time a user accesses it? Wouldn't it be a better idea to create the page once, and then use it for some time? Even if a web page needs to be updated up to the minute (which <a class="docLink" target="_blank" href="http://cnn.com">cnn.com</a> does), on a web site with thousands of requests per second, one minute can mean tens of thousands of requests, which can be served off the cache.</p>
<p class="docText">You need to follow two steps to take advantage of content caching:</p>
<ul><LI><p class="docList">You must realize which parts of your application can take advantage of it.</P></li><li><p class="docList">You need to define the content caching dependencies for each of your pages.</P></li></ul>
<p class="docText">Realizing which pages can be content cached can be more challenging than you think. For example, while cnn.com's front page appears to be a perfect candidate for content caching, things like personalization can complicate matters. When it comes to determining which pages of your application can use content caching, there's no replacement for knowing the semantics of your application inside out.</p>
<p class="docText">That said, you can use these guidelines when trying to decide whether a certain page can benefit from content caching:<a name="ch14index239"></a><a name="ch14index240"></a><a name="ch14index241"></a></p>
<ul><li><p class="docList">Is this page likely to render in exactly the same way across long periods of time? If the answer is yes, it may be a good candidate for content caching. Note that the meaning of &quot;long&quot; is relative in this context; as previously illustrated, one minute can be considered a long time, and an hour an eternity.</P></li><LI><p class="docList">Does this page render differently for different users? If the answer is yes, typically this page is not a good candidate for content caching. This is a rule of the thumb, thoughif the number of users accessing the page is small enough and yet you expect them to access this page repeatedly, it may still benefit from content caching.</p></LI><li><p class="docList">Does this page render in exactly the same way over long periods of time, but has a small personalized portion inside it? If so, this page is likely to be a good candidate for partial-page or exclusive caching.</p></li></ul>
<p class="docText">Once you find a page you wish to content cache, you need to define several things (see <a class="docLink" href="#ch14fig13">Figure 14.13</a>):</P>
<UL><li><p class="docText">
<span class="docEmphStrong">The page's TTL, or Time To Live.</span> 
The TTL is the maximum period of time during which a cached copy of the page will be used. After that time, the cached copy is discarded, the page is executed over again, and a new cached copy is generated.</p></li><li><p class="docText">
<span class="docEmphStrong">The page's dependencies.</span> 
Almost all pages depend on <tt>GET</tt> input. That is, <tt>read_article.php?article_id=7</tt> is likely to create a completely different page than <tt>read_article.php?article_id=7&amp;page=2</tt> or <tt>read_article.php?article_id=5</tt>. In addition, many pages may depend on cookie variables (such as whether the user is logged in or not), server/browser variables (such as the browser type or the preferred language) or session variables.<a name="ch14index242"></a><a name="ch14index243"></a><a name="ch14index244"></a></P></li></ul>
<a name="ch14fig13"></a><P><center><h5 class="docFigureTitle">Figure 14.13. Defining caching conditions in the Zend Performance Suite.</H5>
<p class="docText"><div class="v1"><a target="_self" href="images/013147149X/graphics/14fig13_alt.jpg;380137">[View full size image]</a></div><img border="0" alt="" width="500" height="268" SRC="images/013147149X/graphics/14fig13.jpg;380137"></p></center></p><br>
<p class="docText">In some cases, full-page caching for all the different permutations of a given page is impractical. In such cases, you still might be able to use two methods in order to benefit from dynamic content caching. One is partial caching, and the other is exclusive caching.</p>
<p class="docText"><span class="docEmphStrong">Partial caching</span> allows the use of content caching in pages that cannot be fully cached. For example, if your page has a personalized header and footer but the bulk of the content looks the same for all users, you can use the ZPS's partial caching API functions to save the cacheable parts but let the personalized parts of the page execute normally. The result would be eliminating the overhead involved with the bulk of the page, without harming personalization. The drawback of this method is that it involves changes to your application's code, which many developers prefer to avoid.<a name="ch14index245"></a><a name="ch14index246"></a><a name="ch14index247"></a><a name="ch14index248"></a><a name="ch14index249"></a></p>
<p class="docText">The other alternative, <span class="docEmphStrong">exclusive caching</span>, has to do with statistics. On many web sites that offer personalization, it turns out that many of the users don't actually log in, personalize, and view the page in its default settings. Typical ratings range between 5080 percent of the users who don't bother to log in. If your web site adheres to these statistics, exclusive caching may be for you. With exclusive caching, instead of caching only the parts of the page that look the same for all users, the page is cached in its entirety. The trick is that the cached copy is only used if the user is not logged in and the default web page is requested. If the ZPS detects that the user is logged in, it executes the page normally, without using any cached data. By using this method, you can achieve ''perfect'' content caching for 5080 percent of your page views, without making any modifications to your code. <a class="docLink" href="ch14lev1sec2.html#ch14fig03">Figure 14.3</a> shows an example for exclusive caching settings; with these settings, the page is served off the cache <span class="docEmphasis">only</span> if the Logged_In cookie is not present.<a name="ch14index250"></a><a name="ch14index251"></a><a name="ch14index252"></a><a name="ch14index253"></a><a name="ch14index254"></a></p>
<a name="ch14lev2sec15"></a><h4 class="docSection2Title">14.8.4. Content Compression</h4>
<p class="docText">Compression of HTTP pages is one of the best-kept secrets of the web. Few people know that, but literally all the major browsers today are capable of working with compressed content, decompress it on-the-fly, and show it as if it was uncompressed. If properly implemented, the use of content compression can result in the reduction of around 90 percent of your HTTP traffic, while both saving bandwidth and improving the experience of users over slow links.<a name="ch14index255"></a><a name="ch14index256"></a><a name="ch14index257"></a><a name="ch14index258"></a></p>
<p class="docText">Unlike other types of performance boosting, content compression actually demands more of the server. Because compression is an expensive operation, in terms of overhead, it doesn't always make sense to use it in conjunction with PHP applications. Sometimes, especially if most of your users access your application over fast links, the overhead involved with compression will most probably result in an overall decrease of performance; the time it takes to compress the page will be longer than the time saved sending the data.</p>
<p class="docText">However, the Zend Performance Suite provides a unique solution that combines the power of dynamic content caching with that of <span class="docEmphStrong">content compression</span>. The ZPS allows you to enable content compression selectively, only for the pages that are served off the cache (see <a class="docLink" href="#ch14fig14">Figure 14.14</a>). When using this feature, the ZPS keeps two copies for each cached page: one that is plain text, and one that is compressed. The ZPS automatically detects whether the connecting browser is capable of understanding compressed content, and serves the correct copy accordingly. That way, the overhead involved in on-the-fly compression is avoided, and you can enjoy the benefits of content compression without incurring the penalty of increased CPU utilization.<a name="ch14index259"></a><a name="ch14index260"></a><a name="ch14index261"></a><a name="ch14index262"></a></p>
<a name="ch14fig14"></a><p><center><h5 class="docFigureTitle">Figure 14.14. Compression test in the Zend Performance Suite.</h5>
<p class="docText"><div class="v1"><a target="_self" href="images/013147149X/graphics/14fig14_alt.jpg;380137">[View full size image]</a></div><img border="0" alt="" width="500" height="444" SRC="images/013147149X/graphics/14fig14.gif;380137"></p></center></p><BR>
<a href="28981535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><UL></ul></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14lev1sec7.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=ch14lev1sec9.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>